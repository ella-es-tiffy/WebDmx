# DMX Web Software - Development Guidelines

## Architecture Principles

### 1. Object-Oriented Programming (OOP) Only
- All code must follow OOP principles
- Use classes, interfaces, inheritance, encapsulation
- No procedural/functional spaghetti code
- Proper separation of concerns

### 2. API-Based Communication
- Frontend ↔ Backend communication via REST APIs and WebSocket APIs
- JSON data format
- Proper HTTP methods (GET, POST, PUT, DELETE)
- RESTful endpoint design

### 3. Performance & Efficiency
- Optimize for real-time DMX operations
- Minimize latency between UI and hardware
- Efficient data structures
- Non-blocking I/O operations
- Memory-efficient implementations

### 4. Clean Code - No Spaghetti
- Clear separation of concerns
- Single Responsibility Principle
- DRY (Don't Repeat Yourself)
- Readable, maintainable code
- Proper naming conventions
- Code documentation where needed

### 5. Modern Standards Only
- Use latest language features (ES2024+ for JavaScript/TypeScript)
- No deprecated methods or libraries
- Modern async/await patterns (no callback hell)
- Current best practices

### 6. Frontend Framework Usage
- **CSS Framework:** Use modern CSS framework (TailwindCSS, Bootstrap 5, or similar)
- **JavaScript Framework:** Modern frameworks allowed (Vue.js, React, Alpine.js)
- **PHP Framework (if needed):** Use modern approach, no raw PHP spaghetti
- Responsive design
- Component-based architecture

### 7. Version Control with Git
- **Repository:** https://github.com/ella-es-tiffy/WebDmx
- All code must be tracked in Git
- Proper branch management
- Clear commit messages

### 8. Semantic Versioning
- Follow SemVer (MAJOR.MINOR.PATCH)
- Document version changes in CHANGELOG.md
- Tag releases properly
- Breaking changes must bump MAJOR version

### 9. Regular Commits
- Commit frequently with meaningful messages
- Each commit should represent a logical unit of work
- Format: `[type]: description` (e.g., `feat: add DMX channel controller`, `fix: serial port connection issue`)
- Types: feat, fix, refactor, docs, style, test, chore
- Push to remote regularly

## Technology Stack

### Backend
- **Language:** Node.js with TypeScript
- **Serial Communication:** `serialport` library
- **WebSocket:** `ws` or `socket.io`
- **REST API:** Express.js with TypeScript
- **Architecture:** Clean OOP with classes and interfaces

### Frontend
- **HTML5 + Modern CSS Framework**
- **JavaScript/TypeScript with modern framework**
- **WebSocket client for real-time updates**
- **REST API client (fetch/axios)**

### Database (if needed)
- MySQL 8.0 (already in Docker setup)
- Proper ORM if used (TypeORM, Sequelize)

## Code Structure Example

```
dmx_web/
├── backend/
│   ├── src/
│   │   ├── controllers/     # API endpoint handlers
│   │   ├── services/        # Business logic
│   │   ├── models/          # Data models
│   │   ├── interfaces/      # TypeScript interfaces
│   │   ├── dmx/             # DMX-specific classes
│   │   └── app.ts           # Main application
│   ├── package.json
│   └── tsconfig.json
├── public/                   # Frontend (served by Apache)
│   ├── assets/
│   ├── js/
│   ├── css/
│   └── index.html
└── docker-compose.yml
```

## Naming Conventions
- Classes: PascalCase (e.g., `DmxController`, `LightFixture`)
- Methods/Functions: camelCase (e.g., `sendDmxData()`, `updateChannel()`)
- Constants: UPPER_SNAKE_CASE (e.g., `DMX_UNIVERSE_SIZE`)
- Files: kebab-case (e.g., `dmx-controller.ts`)

## Quality Requirements
- Type safety (TypeScript strict mode)
- Error handling on all external operations
- Input validation
- Proper logging
- Clean git commits
